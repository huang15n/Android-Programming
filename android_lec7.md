
#  Activity Lifecycle

activity life cycle is different states that an activity can be in because a lot of things that can happen to your ap while running 


## preview 
you should be aware of those and your code might want to respond to some of those things, those are going. you do not really learn it unless you go try it. it is a little lower presssure way for you to try it a little bit and sortof flush out some of the intial understandings and misunderstandings, you might get stuck on. this is more cumersome thing in android than other places 

will it explode and break in ten different ways that you need it to come and fix. it is livable 
I am only one data point 

there is usually more than one way to get something to work, I think sometimes the discouverability is the hard part. sometimes it is just like you cannot get it at your fingertips 


#### R are constants that are integer for id numbers that are automatically created for you by android studio IDE 
R.layout, this is a class, there is a class named R and it is automatically generated by android studio and what it does is it looks at all your resources directories and it looks at all. we have raw text and xml files that you are going to read and all drawables. And it declares unique id numbers for all of that. It makes a list of constant valus in fact if you are curious, you can right click and go to declaration of this. you do not have to worry about too much of it, but occassionally and in this case you did not have to write that linke code like that was automatically generated 

sometimes if the R. underlining and saying it is not found that does not exist, it won't compile, if that happens, it can come with a couple reason, long story short usually if you tell it to clean out or build your project, it will usually fix that because it will regenerate the R class. why would R class would be messed up or gone? sometimes when people cut and paste projects or files they are moving around directires or download a zip off the internet. they surprised android studio by dropping in files into a way that it did not expect or it. somtimes it just flushes everything out 




#### setOnItemLongClickListener  

this sort mostly works except it says type mismach requried boolean found, so that is incomprehensible. the function you pass for long click listener has to have a boolean return type 
```java 
        butt1.setOnLongClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                tv.setText("this is right!");
                Toast.makeText(this, "this is clicked and held long", Toast.LENGTH_SHORT);

            }
        });

```
you do not really return true in lambda 
all the same code would normally work except you have to return true or false at the end for it to compile 

```java


        butt1.setOnLongClickListener(new View.OnLongClickListener() {
            @Override
            public boolean onLongClick(View v) {

                        tv.setText("this is right!");
                        Toast.makeText(getApplicationContext(), "this is clicked and held long", Toast.LENGTH_SHORT).show();




                return false;
            }
        });


```

so that is why you have to put one more line that says true or false at the bottom. does that make sense to you? 



## the Activity Lifecyle 


I am gonna open my slides up for that 

activity lifecycle is basically about the differnet states and different things that can happen to an activity, you are start up, it can be actively running, upi can pause or resume an activity based on whether you know other thinsg jump up in front of it or other activities take precedence over it 


#### an activity can be thought of as being in one of serveral states 
- start: in process of loading up, but not fully loaded 
- running: Done loading and now visible on the screen 
- paused: partially obscured or out of focus, but not shut down 
- stopped: no longer active, but still in the device's active memory 
- destroyed: shutdown and no longer currently loaded in memory 

#### transitions between these states are represented by events that you can listen to in your activity code 
- onCreate, onPause, onResume, onStop, onDestroy 


a lot of android programmers find this activity lifecyle stuff to be sort of needlessly complicated because there is a whole bunch of different states activity can be in 

I think intuitively it is sort like there is only a couple of states, either it is running or it is not. hopefully this will conceptually we can kinda flatten some of this and take away some of the complexity out of it 

there are methods you can write in your activity that will be called when you activity transitions to different states and so in that state you can writecode that will respond to those states or changes in states going forward 



## Activity lifecyle 

onCreate() 
   |
   onStart   <- onRestart
   |
   onRestoreInstanceState() 
   |
   onResume() 
   |
   onSaveInstanceState() 
   |
   onPause()
   |
   onStop() 
   |
   onDestroy() 



onCreate() and onDestroy() are included entire lifetime 
others are visible lifetime() 
onReume() / onSaveInstanceState()/ onPause() are foreground lifetime 


1. when you app loads up your it gets created -- the moment it gets created it gets a method onCreate()
when you write an activity, it automatically writes an onCreate() method for you, you are all aware of this 


2. after it calls onCreate() it also calls a method on your activity onStart() 
if you do not write that method, nothing happens, if you do write that method, android will call that method on you 
and of course how that works is through the plubing of inheritance like the superclass activity has that method in it already and its empty and it does not do anything or it does not do that much but you can override that with your version does something 


3. there is other methods called onRestoreInstanceState() and onResune() 
and then you sit there and activity runs 

4. then after a while perhaps for some reasons your activity stop running maybe you jump in front of your app on the screen which caused these transitions in a minute but something caused your activity to stop run
first thing it does is it runs a method called onSaveInstanceState() then it calls something onPause() 
your activity could sit here for a while pause and eventually resume in which case it would jump up here and call onResume() and then be running again 

or more serious things could happen like your whole activity could be stopped your whole app could become destroyed 

the missing piece here is what caused when moving to different states 

the short version is any one of those methods we could go into our activity and we could write one and then android would call it 


if I type here onStart and it will autosuggest what do you mean onStart and then it sorts fills in the right heading and right parameters if any kind of sets it up the right way so you do not have to memorize each one, then I want to insert printing message every time when it gets called , if you want to on android studio in the bottom, we have to use a slightly different command to print a message you notice. I do not want a bunch of toast flying around. you can say Log.i(label, message);
it will show me the order of them getting called 




```java
  
    @Override
    protected void onStart() {
        super.onStart();
        Log.i("eddie", "onStart() was called");
        tv.setText("onStart()");
    }

    @Override
    protected void onRestoreInstanceState(@NonNull Bundle savedInstanceState) {
        super.onRestoreInstanceState(savedInstanceState);
        Log.i("eddie", "onRestoredInstanceState() was called");
        tv.setText("onRestoredInstanceState() ");
    }

    @Override
    protected void onResume() {
        super.onResume();
        Log.i("eddie", "onResume() was called");
        tv.setText("onResume() ");
    }

    @Override
    public void onSaveInstanceState(@NonNull Bundle outState, @NonNull PersistableBundle outPersistentState) {
        super.onSaveInstanceState(outState, outPersistentState);
        Log.i("eddie", "onSaveInstanceState() was called");
        tv.setText("onSaveInstanceState() ");
    }

    @Override
    protected void onPause() {
        super.onPause();
        Log.i("eddie", "onPause() was called");
        tv.setText("onPause() ");
    }

    @Override
    protected void onStop() {
        super.onStop();
        Log.i("eddie", "onStop() was called");
        tv.setText("onStop()");
    }

    @Override
    protected void onDestroy() {
        super.onDestroy();
        Log.i("eddie", "onDestroy() was called");
        tv.setText("onDestroy()");
    }

    @Override
    protected void onRestart() {
        super.onRestart();
        Log.i("eddie", "onRestart()  was called");
        tv.setText("onRestart()");


    }
```



I just want to see ones of these get called and when does it do it 


when we start the log, it calls onStart() and onResume() 
so if I scroll back through the log 
2021-10-20 11:24:10.984 15188-15188/com.example.dictionaryactivitylifecycle I/eddie: onStart() was called
2021-10-20 11:24:12.401 15188-15188/com.example.dictionaryactivitylifecycle I/eddie: onResume() was called


if I go back to the desktop here 
it shows onPause() and OnStop() were called 


if I loaded the app back up it says onRestart(), onStart(), onResume()
it was pause and stop before when I ran the app again it did onRestart() onStart(), onResume() 

it is not lying to you generally right? we will ocme back later 

why it is not called onRestoreInstanceSate() ? 
that is a good question, I think it might be because there are two versions of that 

run android is really hard to do demos, it is terrifying if I exit out of the app here it calls onPause() and onStop() 
if I go back in, onRestart() onStart() onResume() 

in general these mehods getting called 

I tihnk the part that is confusing initially is why so many states? why not just like started and stopped kind of, am i running or am i not running? 
I will try to unpack that in next few sections 


## Activity State transition 
- jumping between activties in the same app: onPause/onResume 

- jump between two apps that are in memory : onStop/onStart

some of these transitions doing stuff within your app and some of them involve doing stuff between multiple apps 
if you exit out of your app and going to the desktop 
it pauses and stop your activity 

but if you have acitivyt up and then you pop up something on top of it brieft for a second like a little dialog box or something temporary and then that closes, that is just a pause and a resume 

a stop is like that activity is actually not visible on the screen so I stop it 
pause means it might still be there but there might be something obscuring it so it is not listening to your input right at this moment 

there is even more serious which is like onDestroy you app has been quit out of and unloaded out of the memory 
if you use whatsapp and then you jump over to some other app like your email 
then you come back to whatsapp it sort of like came back where you were it remembers what screen you were on who you were chatting with like your state what you were doing is sort of still right there 

differs a little bit from app to app it is sometimes kind of hard to predict if I jump back to twitter will it be where i was or go back to the start or whatever? 

sometimes the app remembers what I was dong as long as I was not away from the app for a very long time 



you have got some sort of app that is like visible on screen right now 
if you have some other app that you launch, it takes your app and sort of sets it aside 
it is still there and it is still in the memory of the phone you know 
your original app number one when you stop using him and you jump instead  to app number 2 
one does not just get like trashed and thrown away forever just sets it to the side 
and it runs app number two but like if app no.2 starts doing stuff  that is memory intensive . at some point if it needs the memory, it will just get rid of app no 1 and throw it out 

it does not mean it deletes it from your phone or you have to reinstall or something 

it means it is not currently running it is not loaded and it is not active in the memory of the phone 
so the difference between sitting aside just not visible on screen 
that is when you are stop

but if this gets actually out of memory and that one gets actually completely thrown away where it is just gone, that is called being destroyed
if you get destroyed, it will not remember who you were snapchatting with or what email message you had open or something 

you probably go back to the initial state of the app like onStart() 

an app that sort of seems to be open to away around always listening it is always able to notify you, those sort of always present apps, they use a feature called services , all the stuff right now is sort distinct and separate from that and in fact whta happens is the app itself does get thrown out of the memory is not running but it has this kind of little service that is spinning around running on the background and that does nt get shut down that does not close it states running 

you install a bunch of apps and a lot of those apps launch services that constantly running on your phone even when you are not using that even if service you are not using 

it is not like explicit it is text only, the messages are not horrible offensive.  and he just moved on and like it is not a big thing. it is lowkey and a bit freaky. tales of a clture moe interesting than this one, I do not know I was going with thta 


I complete lost my train of thought 

you have these apps that install services that stay running and that eats up the memory 

the thing about onDestroy() is it was telling you when it gets called and your app gets destroyed when android decides it needs the memory to reclaim that memory, that might happen shortly after you exit your app or an hour after your exit your app or it totally is kind of up to android, it is not up to you  
it does not have control over that and so it is unpredictable 

you could listen for it in case you want to respond to that action in some way but i cannot easily demo it here because it is up to the phone to destroy the app or not 

if you exit the app that actually does flush it out of the memory forces android get rid of it right? there is not a similar thing on an iphone when you pop up list of all your apps don't you swipe them up to throw them away or something 
it is like cathing your patner for cheating 

just to clarify that is not something that happened to me 

that calls android to unload the app out of the phone's memory but outside of that you just using the phone as a normal user you do not have much ability to predict when that will happen 

## Activity instance state 

#### instance state: current state of an activity 
which boxes are checked 
any text typed into text box 
values of any private fields 
.....


example: in the app at right, the instance state is that the checkbox is checked,and the image is showing 


in theory if we quit the app and reload the app like destroyed it swiped up like you asked about if we reloaded it would be in that state anymore 


what is interesting is that if you disturb an activity in certain ways, you can lose the instance of that state, you can lose track of the instance state of the app 

## Lose activity state 
several actions can cause your activity's state to be lost 
when you grom from one activity to another and back, whitin same app 
when uou launch another app and then combe back
when you rotate the device's orientation from portrait to landscape 
....


if you jump out of your activity and come back or jump to another app and come back sometimes the instant state is lost or forgotten 

and actually a particular thing that is surprising to a lot of people thta causes you to lose your instance state is even if you just rotate your app from potrait to landscape, you lose your state 


there are some side bar buttons, if you click the rotation key and it will pretend to rotate the phone sideways and it will singal like the most phones have like a gyroscope so it detc which ways up 

that is more sensible than I thought it was gonna do 

if you have an android device you can set, the most phones the default phones if you turn it it will detect that t is sideways and it will relay out and redraw the screen. I usually tell my phone not to do that because i am often like reading side down hanging from a limb trying to change a diaper I do not want to rotate it upside down for a reason and leave it right side up 

you touch autorotation, i think it will already be on 

do you see how it swtiched to its view> 

the radio button sometimes it breaks radio button which is showing stuff as well 

it is not because this app is buggy or something, it is just the thing about how android behaves 

it is kinda unpredictable, it is all messed up, it all get weird 

in android there are certain states, there are certain actions you can take that cause the app to lose its state or forget to mess up 

much less if sometimes you jump out of your app or activity and jump right back within your same app 


I think one of the most common things that people say when they start learning android development is like why is it when I rotate my app everything breaks
it is like a super common apps, ios is less dumb than this 

## simulate state change in AVD
testing oreitnation change press ctrl+ f11
testing activity shutdown onDestory 
settings-> developer otpions -> do not keep activities 
developer options-> background process limit -> no bg processes 

you can dig around and setting the phone 
or destroy and throw away instant they dsiappear from the screen 
every single time you app is disappear for three sections. it completely uploaded fro mthe memroy and completely reload it so in the general you would not want to do that you might only turn that on temporarily if you want to test so the app functionality does not break or something 


## handling rotation 
a quick way to retain your activity's GUI state on rotation is to set the configChanges attribute of the activity in AndroidManifest.xml 
this does not solve the other cases like lkading other apps / activites 

you want your app not to break 
you write out that   android:configChanges="orientation|screenSize"
and it retains the activity state after rotation 



```xml
  <activity android:name=".MainActivity"
  android:configChanges="orientation|screenSize"
  >
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />

                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>
        </activity>

```

why is when I rotated my app it gets all screwed up? 

basically the short answer is what happens here is that a lot of apps look different dependening on the screen size depending on the orientation 

they have different layouts you have seeen this 

if you are on vertical potrait mode, the video is kind up here and then in the bottom there is a chat window people chatting about the stream 

that is the potrary layout in portrait ode

then if you flip it to landscape mode it just pulls the video to fill a whole screen because it is like a nice wide screen and it fits perfect to this geometry 
so then the chat goes away 


so the default for the app is to completely reload your activity and its layout everytime you rotate your phone that is why it sort of loses some state and some information because it is kinda of reloaging the activity back 

if you app does not want to change layouts for orientation 

if you put that then your app won't mess things up when you rotate 


i think they just did not design it very well but i think what really is happening here is like your activity is an object when it creates and load up on screen it creates an object of this class and that object is associated with the stuff that you are viewing on the screen and when it rotates, it actually throws that object away and makes a new one and so part of the reason the instance state gets messed up is because my object had some private variables that get thrown away and recreated a new object 
it is basically because of creation of the new object and that is why it is broken 

I think we can make an argument that is a bad design that should not be that way that maybe they should sort of keep our object and then resuse it or something but that just is not how they chose to design it 

what am i trying to show you is like these methods we have we are onPause, onResume, onSavedInstanceState on restoration like some of the methods you can use them to avoid these problems you can catch these thigns as they are happening and like react to them and remember things so you won't forget them 

android:configChanges = "orientation
screenSize" avoids your app crash and burn when you rotate the screen but it does not solve some of the other things 


this is not some magic bullets that fixes all your problems for you 

what you do need to do is you need to start like writing some of these functions and I am going to try to give you a sense of what sort of code I wrote a lot of these on whatever methods and I just put a log but I do not think I have done a very good job of justifying like well what kind of code would you write in there instead of a log 




## the onCreate() function 
- onCreate(): called as activity is being initialized
1. creates and sets up the activity object
2. load any static resources like images, layouts, set up menus etc 
3. after it runs, the Activity object exists 
4. think of this as the constructor of the activity 
5. do not actually write a constructorl things will break 


```java

protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
 // any other initialization code 
}
```

you have to have it or else the thing does not work properly 
a crucial thing thta happens in onCreate() is this weird command called setContentView(R.layout.activity); which causes android to go read your xml layout file and actually go and make all the widgets that are described in that file 
this line of code that is inserted for you by the editor that is actually of crucial importance to your activity looking properly 


## the onPause function
- onPause: called when another activity in same app pops up over your current activity 
- may be tempraroy, or on way to termination 
1. stop animations or other actions that consume CPU 
2. commit unsaved change/draft email
3. release system resource that affect battery life 

```java

    @Override
    protected void onPause() {
        super.onPause();
        Log.i("eddie", "onPause() was called");
        tv.setText("onPause() ");
    }


```


your app is running at some point your app pauses 
that means something pops up that is on top of your activity, like a dialogue boxe that is partially obscures what you are doing 
like review pops up something like that happens 
if you play music you want the user to focus on the new thing if you had an animation going on you might pause the animation 

onPause might also mean that your app is on the way to shutting down 

## Testing activity states 
- use the LogCat sytem for looging messages when your app changes states 
1. analogous to println debugging for android apps 
2. apepars in the LogCat console in android studio 


```java
        Log.i("eddie", "onPause() was called");

```


## the onResume function 
- on resume: called when activity starts and when it comes back from having been paused 
1. intialize resources that you will release in onPause() 
2. start/resume animations or other ongoing actions that should only run when activity is visible on screen 


```java

    @Override
    protected void onResume() {
        super.onResume();
        beginAnimation();
        myConnection = new MyConnection();
        myConnection.connect(); 
        Log.i("eddie", "onResume() was called");
        tv.setText("onResume() ");
    }


```

onResume is whatever there used to be someting on top of your activity that was causing it to be pause like a popup box rates this app 

onResume means whatever that popup thing was has now closed either way and now you are back to your activity so I think what you would do here would be kind of opposite of whatever you did it on pause if you pause the music palyback then resume the music playback 
if you pause the animation resume the animation 
if sometimes the popup reivew , the activity behind it kind of like greys it out you know 
it could puts kind of a semi-transparent gray or smear over it like that is probably because they did that they drew a layer of a widget or something that was semi-transparent 
and they probably drew that in onPause and in onResume they probably got rid of that guy 

## onStop() function
- onStop: called when activity is no longer running 
1. user chose another app from recent apps window 
2. user starts a different activity in your app
3. user receves a phone call while in your app 

- onPause is always called before onStop
- onStop performs heavy duty shutdown tasks like writing to a database 

```java 
    @Override
    protected void onStop() {
        super.onStop();
        Log.i("eddie", "onStop() was called");
        tv.setText("onStop()");
    }


```

you no no pixel of that activity is visible on screen anymore 
it is off screen, either your app jumped to another app or because another app popped up in place of your app, or some crucial things come in 

when you jump from your youtube app to anothe app, it stops playing the vide, i mean maybe it is an obvious question 
it still doing all the work to like decode and draw all the pixels in the background and it is not even going to see it so it is like a waste of resources to do that whatever their playback is doing, it is going to like stop the playback, remember the time index and just stop. I mean alhtough I think it not true like some of the newest versions of youtube like they shrink it into a little corner, but that is happenin onStop method still so it is still reacting in some way to that action occuring 


## the onStart() and onRestart() functions
1. onStart: called every  time the activity begins 
2. onRestart: called when the activity was stopped but is started again later, all but the first start 
not as commonly used; favor onResume 
re-open any resource that onStop closed 

onStart is it comes after onCreate just like immediately after onCreated is done call on start 

but it also calls on start if you were stopped 


when I jumped away from the activity it said onPause() or onStop() then I jumped into the activity it did onRestart() or onStart() 

onRestart() is alsmot exactly the same as onSTart() the only difference between them is when the first load occurs, it does not call onRestart() but it calls onStart() 
so it is a little overcomplicated but like why would you want some code that would be an onStart() versus onRestart() 
well, I mean restart means you are coming back you were there and you left and you came back 
verus onStart() you either are coming back or you are just loading the app 

you might want to distinguish between those two things 




```java
   @Override
    protected void onStart() {
        super.onStart();
        Log.i("eddie", "onStart() was called");
        tv.setText("onStart()");
    }
  @Override
    protected void onRestart() {
        super.onRestart();
        Log.i("eddie", "onRestart()  was called");
        tv.setText("onRestart()");


    }
```


I think android overly distingusihes pause, stop and  you know pauses versus stop and it overly distinguishes start versus resume 

i really think could just kind mush those together into each other 


I typically  recommend people to favor onResume and onPause because to me it is just kind of like those are close to the running state and so just like pick a pair, i guess what i would say is even if you do pick onStop or onStart maybe just be consistent and do not do onStart and onPause or onStop or onResume 

###### onStart onStop 
###### onResume onPause 

just to pick a match pair going to write 


## the onDestroy() function
- onDestroy: called when your entire app is being shutdown and uploaded from memory, 

unpredicatbale exactly when/if it will be called 
can be called whenever the system wants to reclaim the memory used by your app 
generally favor onPause or onStop because they are called in a predictable and timely manner

```java
    @Override
    protected void onDestroy() {
        super.onDestroy();
        Log.i("eddie", "onDestroy() was called");
        tv.setText("onDestroy()");
    }

```

that is like when you are exiting out of memory right before you get flushed out of the memory android calls this on you so if you have any last words speak now or ever hold your pieces 

what would you do it there? i think when you have data saved and loaded in 
although frankly I think most of the time I do not use onDestroy(), I never override this method any sort of work that you might think I want to do this when the app shuts down. 

I would typically want to do it more like in onStop() or onPause() because you know you do not know when onDestroy is going to get called, and one thing you have to keep in mind is that in case of catastrophe sometimes these things do not get called like if I dropped the phone and it smacks on the hard concrete and the battery pops out and phone dies, it does not call onDestroy or any function it just turns off right? so you cannot be guarantee some of these things so you might want onStop() instead of onDestroy() because that is more liekly to actually be guaranteed to get called sometimes. 



## onSaveInstanceState() function && onRestoreInstanceSate() function 

- when an activity is being destroyed, onSaveIstanceState is also called, 
*non-persistent state*: stays for now, but lost on shutdown/reboot 

- accepts a Bundle parameter storing key/value paris 
bundle is passed back to actvity if it is recreated later 
superlass version saves state of any Views that have an ID 


we have the issue with state activity being lost or whatever, these bundles if you go look hang on. 
if you look at onCreate, it takes a parameter calle Bundle savedInstanceState 


```java

  protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
  }
```
a bundle is a bit like an intent 

it can be like its almost a map you can store pairs key values in it
a bundle is kind of the same way in the sense that it stores key value pairs 

but an intent is sort of used to launch something 
a bundle sort of does not have the launching aspect

I mean frankly I think they should have just made this parameter be a map like I think that would have been more simpler but that is basically just think of it as a map, it has put methods and a get method


these bundles can be used as your activity gets shutdown and loaded back up 


you can use these bundles to remember the instance state so you do not forget about that 


as you activity start to get taken off the screen or whatever 

you can store stuff into a bundle you just put stuff in here and then later when your instant state gets restored, you can pull the stuff back out of bundle and your app will remember it again 



when you stop running and it asks you if you want to save your instance and then you get resumed it asks if you want to restore your instant state so another thing you can do is instead of putting code in pause or resume, you can write these on saveInstanceState() onSaveInstanceState() method 
the difference between these two is they take this bundle parameter, yo ucan pack stuff in there 

one thing you can do is that, you could say, well
```java


 @Override
    public void onSaveInstanceState(@NonNull Bundle outState, @NonNull PersistableBundle outPersistentState) {
        super.onSaveInstanceState(outState, outPersistentState);
        outState.putString("name",'value');
        Log.i("eddie", "onSaveInstanceState() was called");
        tv.setText("onSaveInstanceState() ");
    }

```


one one on onRestoreInstanceSTate() saveIstanceState.getString("name");

```java

  @Override
    protected void onRestoreInstanceState(@NonNull Bundle savedInstanceState) {
        super.onRestoreInstanceState(savedInstanceState);
        Log.i("eddie", "onRestoredInstanceState() was called");
        String result = saveIstanceState.getString("name");
        tv.setText("onRestoredInstanceState() ");
    }

```


I could get back out with the same key that I put in before 

so those two methods allow you to sort of remember something across the boundary of like my app got removed from the memory and recreated but I do not want to forget the private variables I had going at the time of that 


bundles, androids does all the things for you, android passes you in a bundle here when you are saving the state

you could do something with it if you want to and then it sort of holds onto thta and remembers it 

it throws away your object and it makes a new one but it does not throw this away, it keeps the bundle and then when you come back and it makes a new object of you, and it says here is that bundle you saved before and here it is 

you can sort of unpack your bundle and pull everything back out of there 

you can use what was in there to restore whatever 
basically whatever was in there, you can use it to reproduce the state of the app that was originally there 

is it associated with the class as a whole of this activity? or is it assoicated with a particular object of the client? 
I mean I guess what I would say is like if you are running your activity for the first time there is an object number one of your activity class that object has this method called on it and that object fills in this bundle, and now activity object 1 gets thrown in the trash or whatever 

the bundle is saved somewhere else by some part of android that is sort of magical to us and later when you come back to load tha tapp, that is like activity class object 2 then the bundle that number 1 made gets handed to number 2 

I guess I am trying to answer to your question the right way 
I would say it is a message that is passed from one to another so those particular two objecst created this bundle between each other but it does not like if there is a whole bunch of objects of this type 
the bundle is not given to all of them it is only given the one that got thrown away to the replacement new one that got made to take its place later 



what if I have a whole bunch of data, it is going to be a pain in the ass! I have to do this right? is there like some magic remember everything metohd or way to make this easiser? 

I got these fields even to just save save or store restore, that is starting to because they are collections, and that is kind of complicated quickly 
I would say is there is not a magical one line way to do that in android,
but pretty soon there is a whole bunch of libraries for android that are easy to set up and easy to install 
and there are ones for this where there are libraries you can just basically flag what data you care about as you create it and then you sort of automatically magically put it in bundles and pull it out of bundles for you. you might say well why do not we just talk about that state and not deal with all these? 

I think the reason is I want to start here with regular raw android because it is like it is hard to understand the need for those libraries or you sort of become dependent on them and library does not work or gets changed or whatever then you are just lost and os 
you will say screw it and jump over it and do not deal with it at all 
just take the word out of the bundle and put it back in there 

what else do you need to save and store for this to work?? 

you have to make sure you private variable has the right stuff 

```java

    @Override
    protected void onRestoreInstanceState(@NonNull Bundle savedInstanceState) {
        super.onRestoreInstanceState(savedInstanceState);
        Log.i("eddie", "onRestoredInstanceState() was called");
        tv.setText("onRestoredInstanceState() ");

       ArrayList<String> newDictionary = savedInstanceState.getStringArrayList("dictionary");

     //   Log.v("what",newDictionary.get(0));
    //  adapter = new ArrayAdapter<>(this, android.R.layout.simple_list_item_1,newDictionary);

       if(newDictionary == null){
           Log.v("edhuang","this is null");
       }else{
           Log.v("edhuang","this is not null");
       }
        // this cannot work adapter.notifyDataSetChanged();


    }


    @Override
    public void onSaveInstanceState(@NonNull Bundle outState, @NonNull PersistableBundle outPersistentState) {
        super.onSaveInstanceState(outState, outPersistentState);
        Log.i("eddie", "onSaveInstanceState() was called");
        tv.setText("onSaveInstanceState() ");
        outState.putStringArrayList("dictionary",dictionary);
    }


```
and you have to make sure what is on the screen has the right sutff on it 

you try to set up all your private variables and all your widgets for the stuff on 

I do not have a lot of confidencne in it 
now it handles rotations properly it does not barf up










































 









































































































































































